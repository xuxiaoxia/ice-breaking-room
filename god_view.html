<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç ´å†°é¦† - ä¸Šå¸è§†è§’å…¨å±€æŒæ§ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Microsoft YaHei', sans-serif; touch-action: none; user-select: none; }
        
        /* é¡¶éƒ¨è¯´æ˜é¢æ¿ */
        #instructions {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.9); padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 1000; pointer-events: none;
            border: 1px solid #ccc;
        }

        /* ç”µæ¢¯æ§åˆ¶é¢æ¿æ ·å¼ (ä¿æŒä¸å˜) */
        #elevator-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 10px;
            display: none; flex-direction: column; gap: 10px; z-index: 1000;
            border: 2px solid #555; pointer-events: auto;
        }
        .ele-btn {
            width: 45px; height: 45px; border-radius: 5px; border: 1px solid #777;
            background: #222; color: #fff; font-size: 18px; font-weight: bold;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            transition: all 0.2s; user-select: none;
        }
        .ele-btn:hover { background: #555; }
        .ele-btn.active { background: #0078D7; border-color: #00B4FF; box-shadow: 0 0 10px #00B4FF; }
        .ele-hint { color: #aaa; font-size: 12px; text-align: center; margin-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>
    <div id="instructions">
        <strong>[ ç ´å†°é¦† - ä¸Šå¸è§†è§’ ]</strong><br/><br/>
        <span>ğŸ‘‰ <b>å·¦é”®æ‹–æ‹½</b>ï¼šæ—‹è½¬è§†è§’</span><br/>
        <span>ğŸ‘‰ <b>å³é”®æ‹–æ‹½</b>ï¼šå¹³ç§»è§†è§’</span><br/>
        <span>ğŸ‘‰ <b>æ»šè½®ç¼©æ”¾</b>ï¼šæ‹‰è¿‘/æ‹‰è¿œ</span><br/>
        <span>ğŸ‘‰ <b>å•å‡»é¼ æ ‡å·¦é”®</b>ï¼šå¼€é—¨ / æ§åˆ¶é®å…‰æ¿</span>
    </div>

    <div id="elevator-panel">
        <div class="ele-btn" id="btn-4" onclick="callElevator(4)">4F</div>
        <div class="ele-btn" id="btn-3" onclick="callElevator(3)">3F</div>
        <div class="ele-btn" id="btn-2" onclick="callElevator(2)">2F</div>
        <div class="ele-btn active" id="btn-1" onclick="callElevator(1)">1F</div>
        <div class="ele-hint">æŒ‰é”®ç›˜ 1~4<br/>(æ‰‹æœºå¯ç‚¹å‡»)</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- ç”µæ¢¯æ ¸å¿ƒå…¨å±€å˜é‡ ---
        let currentElevatorFloor = 1; 
        let targetElevatorFloor = 1;
        let isElevatorMoving = false;
        let elevatorObj = null;
        let isAllCurrentDoorsClosed = true;
        const FLOOR_HEIGHT = 3.0; // æ¯å±‚é«˜åº¦ 3 ç±³
        
        // å…¨å±€ç”µæ¢¯è°ƒåº¦å‡½æ•°
        window.callElevator = function(floor) {
            if (!isElevatorMoving && floor !== currentElevatorFloor) {
                targetElevatorFloor = floor;
                isElevatorMoving = true;
                // ç«‹å³æ›´æ–° UI æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.ele-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('btn-' + floor).classList.add('active');
            }
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xD8EDF2);

        // ã€ä¿®æ”¹ã€‘ï¼šå°†æ‘„åƒæœºæ”¾ç½®åœ¨ç©ºä¸­ï¼Œä¿¯ç°å»ºç­‘
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 20); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // ä¿ç•™ä½ ä¹‹å‰ä¸æƒ³è¦çš„åƒç´ ä¼˜åŒ–ï¼ˆå¦‚æœè¿˜æ˜¯å¡å¯ä»¥è‡ªè¡ŒåŠ å›æ¥ï¼‰
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); 
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);
        // ã€ä¿®æ”¹ã€‘ï¼šä¸Šå¸è§†è§’ä¸‹ï¼Œç‚¹å…‰æºä¸å†è·Ÿç€ç›¸æœºèµ°ï¼Œè€Œæ˜¯å›ºå®šåœ¨å»ºç­‘ä¸­å¿ƒä¸Šæ–¹
        const pointLight = new THREE.PointLight(0xffffff, 0.6, 30);
        pointLight.position.set(0, 15, 0);
        scene.add(pointLight);

        // ã€ä¿®æ”¹ã€‘ï¼šåŠ å…¥ OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 6, 0); // è§†è§’ä¸­å¿ƒå¯¹å‡†ç ´å†°é¦†çš„ä¸­å¿ƒé«˜åº¦
        controls.enableDamping = true; // å¼€å¯ä¸æ»‘æƒ¯æ€§
        controls.dampingFactor = 0.05;
        controls.maxDistance = 50; // é™åˆ¶æœ€è¿œæ‹‰ä¼¸è·ç¦»

        const matteGrayMaterial = new THREE.MeshLambertMaterial({
            color: 0x555555, side: THREE.DoubleSide
        });

        const loader = new THREE.GLTFLoader();
        let roomModel;
        const interactiveDoors = [];
        const interactiveShutters = []; 

        loader.load('room102.glb', (gltf) => {
            roomModel = gltf.scene;
            scene.add(roomModel);
            roomModel.traverse((child) => {
                if (child.isMesh) {
                    if (child.name.includes('Elevator')) {
                        elevatorObj = child;
                    }
                    if (child.name.includes('Shutter')) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.2, roughness: 0.8 });
                    } else if (child.name.includes('Text')) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x2b5797, metalness: 0.8, roughness: 0.6 });
                    } else if (child.name.includes('Window_Glass')) {
                        child.material = new THREE.MeshBasicMaterial({ color: 0x55aaff, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
                    } else if (child.name.includes('Room') || child.name.includes('Door_')){
                        child.material = matteGrayMaterial; 
                    }
                }
                if (child.name.includes('Door')) {
                    child.userData.isOpen = false; 
                    child.userData.baseRotationY = child.rotation.y;
                    child.userData.targetRotationY = child.rotation.y; 
                    interactiveDoors.push(child);
                }
                if (child.name.includes('Shutter')) {
                    child.userData.isSlid = false;
                    child.userData.basePosZ = child.position.z;
                    child.userData.targetPosZ = child.position.z;
                    interactiveShutters.push(child);
                }
            });
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ã€ä¿®æ”¹ã€‘ï¼šä½¿ç”¨é¼ æ ‡çœŸå®ç‚¹å‡»ä½ç½®å‘å°„å°„çº¿ï¼Œä¸å†æ˜¯ä»å±å¹•æ­£ä¸­å¿ƒå‘å°„
        function onPointerDown(event) {
            // å°†é¼ æ ‡ç‚¹å‡»åæ ‡è½¬æ¢ä¸ºæ ‡å‡†çš„è®¾å¤‡åæ ‡ (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(roomModel ? roomModel.children : [], true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;

                // 1. å¤„ç†é®å…‰æ¿ (Shutter)
                let shutterObj = obj;
                while(shutterObj.parent && !shutterObj.name.includes('Shutter')) {
                    if(shutterObj.parent.type === 'Scene') break; shutterObj = shutterObj.parent;
                }
                if (shutterObj.name.includes('Shutter')) {
                    if (!shutterObj.userData.isSlid) {
                        shutterObj.userData.targetPosZ = shutterObj.userData.basePosZ - 0.8;
                        shutterObj.userData.isSlid = true;
                    } else {
                        shutterObj.userData.targetPosZ = shutterObj.userData.basePosZ;
                        shutterObj.userData.isSlid = false;
                    }
                    return; 
                }

                // 2. å¤„ç†é—¨ (Door)
                let doorObj = obj;
                while(doorObj.parent && !doorObj.name.includes('Door')) {
                    if(doorObj.parent.type === 'Scene') break; doorObj = doorObj.parent;
                }
                
                if (doorObj.name.includes('Door')) {
                    let isOpening = !doorObj.userData.isOpen;
                    let match = doorObj.name.match(/_([1-4])/);
                    let doorFloor = match ? parseInt(match[1]) : 1;

                    // ã€å·å®—æ ¸å¿ƒæœºåˆ¶ã€‘ï¼šç”µæ¢¯ç§»åŠ¨ä¸­ç¦æ­¢å¼€é—¨ï¼›äºŒå±‚åŠä»¥ä¸Šç”µæ¢¯ä¸åœ¨å½“å‰å±‚æ—¶ç¦æ­¢å¼€é—¨
                    if (isOpening) {
                        if (isElevatorMoving) return; 
                        if (doorFloor >= 2 && currentElevatorFloor !== doorFloor) {
                            console.warn(`å®‰å…¨é”å¼ºåˆ¶æ‹¦æˆªï¼šç”µæ¢¯å½“å‰åœ¨ ${currentElevatorFloor} æ¥¼ï¼Œä¸Šå¸ä¹Ÿæ— æ³•æ‰“å¼€ ${doorFloor} æ¥¼çš„é—¨ï¼`);
                            return; 
                        }
                    }

                    let swingDir = doorObj.name.includes('Rev') ? 1 : -1;
                    doorObj.userData.targetRotationY = isOpening ? 
                        doorObj.userData.baseRotationY + swingDir * (Math.PI / 4) : doorObj.userData.baseRotationY; 
                    doorObj.userData.isOpen = isOpening;
                }
            }
        }

        // å…¼å®¹ PC é¼ æ ‡å’Œç§»åŠ¨ç«¯è§¦æ‘¸ç‚¹å‡»
        window.addEventListener('pointerdown', (e) => {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ UI é¢æ¿ï¼Œä¸è¦è§¦å‘å°„çº¿
            if (e.target.classList.contains('ele-btn')) return;
            onPointerDown(e);
        });

        // é”®ç›˜å‘¼å«ç”µæ¢¯å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (isAllCurrentDoorsClosed && !isElevatorMoving) {
                if (e.code === 'Digit1' || e.code === 'Numpad1') window.callElevator(1);
                if (e.code === 'Digit2' || e.code === 'Numpad2') window.callElevator(2);
                if (e.code === 'Digit3' || e.code === 'Numpad3') window.callElevator(3);
                if (e.code === 'Digit4' || e.code === 'Numpad4') window.callElevator(4);
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ä¸Šå¸è§†è§’æ§åˆ¶å™¨
            controls.update();

            // 1. æ£€æŸ¥å½“å‰æ¥¼å±‚çš„ã€å¤–å®¤é—¨ã€‘æ˜¯å¦å·²å…¨éƒ¨å…³å¥½
            isAllCurrentDoorsClosed = true;
            interactiveDoors.forEach(door => {
                if (door.name.includes('Outer')) {
                    let match = door.name.match(/_([1-4])/);
                    let doorFloor = match ? parseInt(match[1]) : 1;
                    if (doorFloor === currentElevatorFloor && door.userData.isOpen) {
                        isAllCurrentDoorsClosed = false;
                    }
                }
            });

            // 2. UI æ§åˆ¶é¢æ¿æ˜¾éšé€»è¾‘ (ä¸Šå¸è§†è§’ä¸‹æ— è§†ç©å®¶ä½ç½®ï¼Œåªå—é—¨çŠ¶æ€é™åˆ¶)
            const panel = document.getElementById('elevator-panel');
            if (isAllCurrentDoorsClosed && !isElevatorMoving) {
                panel.style.display = 'flex';
            } else {
                panel.style.display = 'none';
            }

            // 3. ç”µæ¢¯å¹³å°å‡é™ç‰©ç†å¼•æ“
            if (isElevatorMoving && elevatorObj) {
                let targetY = (targetElevatorFloor - 1) * FLOOR_HEIGHT;
                let currentY = elevatorObj.position.y;
                let dy = targetY - currentY;
                
                if (Math.abs(dy) > 0.05) {
                    let delta = dy * 0.03; 
                    if (Math.abs(delta) < 0.02) delta = Math.sign(dy) * 0.02; 
                    elevatorObj.position.y += delta;
                    // æ³¨æ„ï¼šä¸Šå¸è§†è§’ä¸‹ï¼Œæ‘„åƒæœºé«˜åº¦ä¸å†å¼ºè¡Œè·Ÿéšç”µæ¢¯ä¸€èµ·è¿åŠ¨
                } else {
                    elevatorObj.position.y = targetY;
                    currentElevatorFloor = targetElevatorFloor;
                    isElevatorMoving = false;
                }
            }

            // 4. æ›´æ–°æœºå…³åŠ¨ç”»
            interactiveDoors.forEach(door => {
                door.rotation.y = THREE.MathUtils.lerp(door.rotation.y, door.userData.targetRotationY, 0.1);
            });
            interactiveShutters.forEach(shutter => {
                shutter.position.z = THREE.MathUtils.lerp(shutter.position.z, shutter.userData.targetPosZ, 0.1);
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>