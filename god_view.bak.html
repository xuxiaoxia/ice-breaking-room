<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>破冰馆 - 102 上帝视角沙盘版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Microsoft YaHei', sans-serif; touch-action: none; user-select: none; }
        #instructions {
            position: absolute; top: 10px; left: 10px; 
            background: rgba(255, 255, 255, 0.8); padding: 10px; 
            border-radius: 5px; color: #333; z-index: 100; pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="instructions">
        <strong>[ 102 上帝视角 ]</strong><br/>
        <span>左键拖拽：旋转视角</span><br/>
        <span>右键拖拽：平移沙盘</span><br/>
        <span>滚轮缩放：拉近/推远</span><br/>
        <span>左键点击：开关门/遮光板</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xD8EDF2);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 【修改点2】：把相机拉高，放在斜上方，形成俯视角度
        camera.position.set(15, 20, 15); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 灯光保持不变
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); 
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);

        // 【修改点3】：配置 OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 开启阻尼（丝滑的惯性）
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.1; // 限制视角，防止镜头钻到地底下

        const matteGrayMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555, metalness: 0.0, roughness: 1.0, side: THREE.DoubleSide
        });

        const loader = new THREE.GLTFLoader();
        let roomModel;
        const interactiveDoors = [];
        const interactiveShutters = []; 

        loader.load('room102.glb', (gltf) => {
            roomModel = gltf.scene;
            scene.add(roomModel);
            roomModel.traverse((child) => {
                if (child.isMesh) {
                    // 材质逻辑完全保留
                    if (child.name.includes('Shutter')) {
                        child.material = new THREE.MeshStandardMaterial({ 
                            color: 0x444444, metalness: 0.2, roughness: 0.8 
                        });
                    } else if (child.name.includes('Text')) {
                        child.material = new THREE.MeshStandardMaterial({ 
                            color: 0x2b5797, metalness: 0.8, roughness: 0.6 
                        });
                    } else if (child.name.includes('Window_Glass')) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0x55aaff, transparent: true, opacity: 0.4, side: THREE.DoubleSide 
                        });
                    } else if (child.name.includes('Room') || child.name.includes('Door_')){
                        child.material = matteGrayMaterial; 
                    }
                }
                
                // 机关初始化逻辑完全保留
                if (child.name.includes('Door')) {
                    child.userData.isOpen = false; 
                    child.userData.baseRotationY = child.rotation.y;
                    child.userData.targetRotationY = child.rotation.y; 
                    interactiveDoors.push(child);
                }
                if (child.name.includes('Shutter')) {
                    child.userData.isSlid = false;
                    child.userData.basePosZ = child.position.z;
                    child.userData.targetPosZ = child.position.z;
                    interactiveShutters.push(child);
                }
            });
        });

        // 【修改点4】：鼠标/触屏点击判定转换
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // 使用 pointerdown 可以同时兼容电脑端鼠标左键点击和手机端触摸点击
        window.addEventListener('pointerdown', (event) => {
            // 确保只响应鼠标左键或单指触摸
            if (event.button !== 0 && event.pointerType === 'mouse') return;

            // 将鼠标屏幕坐标转换为 Three.js 的标准化设备坐标 (-1 到 +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            triggerInteract();
        });

        function triggerInteract() {
            // 从相机发出一条穿过鼠标位置的射线
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(roomModel ? roomModel.children : [], true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;

                // 遮光板逻辑完全保留
                let shutterObj = obj;
                while(shutterObj.parent && !shutterObj.name.includes('Shutter')) {
                    if(shutterObj.parent.type === 'Scene') break; shutterObj = shutterObj.parent;
                }
                if (shutterObj.name.includes('Shutter')) {
                    if (!shutterObj.userData.isSlid) {
                        shutterObj.userData.targetPosZ = shutterObj.userData.basePosZ - 0.8;
                        shutterObj.userData.isSlid = true;
                    } else {
                        shutterObj.userData.targetPosZ = shutterObj.userData.basePosZ;
                        shutterObj.userData.isSlid = false;
                    }
                    return; 
                }

                // 门逻辑完全保留
                let doorObj = obj;
                while(doorObj.parent && !doorObj.name.includes('Door')) {
                    if(doorObj.parent.type === 'Scene') break; doorObj = doorObj.parent;
                }
                if (doorObj.name.includes('Door')) {
                    let swingDir = doorObj.name.includes('Rev') ? 1 : -1;
                    doorObj.userData.targetRotationY = !doorObj.userData.isOpen ? 
                        doorObj.userData.baseRotationY + swingDir * (Math.PI / 4) : doorObj.userData.baseRotationY; 
                    doorObj.userData.isOpen = !doorObj.userData.isOpen;
                }
            }
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update(); // 必须在循环中调用以支持阻尼动画

            interactiveDoors.forEach(door => {
                door.rotation.y = THREE.MathUtils.lerp(door.rotation.y, door.userData.targetRotationY, 0.1);
            });

            interactiveShutters.forEach(shutter => {
                shutter.position.z = THREE.MathUtils.lerp(shutter.position.z, shutter.userData.targetPosZ, 0.1);
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>