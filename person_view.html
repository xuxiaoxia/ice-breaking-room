<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>破冰馆 - 完整四层电梯联动版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Microsoft YaHei', sans-serif; touch-action: none; user-select: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background-color: #ff0000; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 100; opacity: 0.8;
        }
        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(255,255,255,0.9); display: flex;
            justify-content: center; align-items: center; color: #333;
            text-align: center; cursor: pointer; z-index: 999;
        }
        #joystick-container {
            position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px;
            background: rgba(0,0,0,0.05); border-radius: 50%; display: none; border: 2px solid rgba(0,0,0,0.1);
        }
        #joystick-knob {
            position: absolute; top: 35px; left: 35px; width: 50px; height: 50px;
            background: rgba(0,0,0,0.2); border-radius: 50%; pointer-events: none;
        }
        
        /* 新增：电梯控制面板样式 */
        #elevator-panel {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0, 0, 0, 0.8); padding: 15px; border-radius: 10px;
            display: none; flex-direction: column; gap: 10px; z-index: 1000;
            border: 2px solid #555; pointer-events: auto;
        }
        .ele-btn {
            width: 45px; height: 45px; border-radius: 5px; border: 1px solid #777;
            background: #222; color: #fff; font-size: 18px; font-weight: bold;
            cursor: pointer; display: flex; justify-content: center; align-items: center;
            transition: all 0.2s; user-select: none;
        }
        .ele-btn:hover { background: #555; }
        .ele-btn.active { background: #0078D7; border-color: #00B4FF; box-shadow: 0 0 10px #00B4FF; }
        .ele-hint { color: #aaa; font-size: 12px; text-align: center; margin-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="blocker">
        <div id="instructions">
            <strong>[ 破冰馆 - 四层探索 ]</strong><br/><br/>
            <span>PC端：点击进入 | WASD 移动 | 鼠标转向 | 左键交互 | 键盘 1-4 乘电梯</span><br/>
            <span>手机端：左侧摇杆移动 | 右侧滑动转向 | 右侧点击交互</span>
        </div>
    </div>
    
    <div id="joystick-container"><div id="joystick-knob"></div></div>

    <div id="elevator-panel">
        <div class="ele-btn" id="btn-4" onclick="callElevator(4)">4F</div>
        <div class="ele-btn" id="btn-3" onclick="callElevator(3)">3F</div>
        <div class="ele-btn" id="btn-2" onclick="callElevator(2)">2F</div>
        <div class="ele-btn active" id="btn-1" onclick="callElevator(1)">1F</div>
        <div class="ele-hint">按键盘 1~4<br/>(手机可点击)</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- 新增：电梯核心全局变量 ---
        let currentElevatorFloor = 1; 
        let targetElevatorFloor = 1;
        let isElevatorMoving = false;
        let elevatorObj = null;
        let isPlayerOnElevator = false;
        let isAllCurrentDoorsClosed = true;
        const FLOOR_HEIGHT = 3.0; // 每层高度 3 米
        
        // 全局电梯调度函数
        window.callElevator = function(floor) {
            if (!isElevatorMoving && floor !== currentElevatorFloor) {
                targetElevatorFloor = floor;
                isElevatorMoving = true;
                // 立即更新 UI 按钮状态
                document.querySelectorAll('.ele-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('btn-' + floor).classList.add('active');
            }
        };
        // -----------------------------

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xD8EDF2);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 1.6, 0); 
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // 强制最高只渲染 1.5 倍物理像素，防止 4K/视网膜屏幕榨干 GPU
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); 
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.6, 15);
        camera.add(pointLight);
        scene.add(camera);

        const matteGrayMaterial = new THREE.MeshLambertMaterial({
            color: 0x555555, side: THREE.DoubleSide
        });

        const loader = new THREE.GLTFLoader();
        let roomModel;
        const interactiveDoors = [];
        const interactiveShutters = []; 
        const objectsToCollide = [];

        // 注意：如果你导出了包含四层的总模型，请替换此处的文件名
        loader.load('room102.glb', (gltf) => {
            roomModel = gltf.scene;
            scene.add(roomModel);
            roomModel.traverse((child) => {
                if (child.isMesh) {
                    
                    // 【新增】：捕获电梯平台组件
                    if (child.name.includes('Elevator')) {
                        elevatorObj = child;
                    }

                    if (child.name.includes('Shutter')) {
                        child.material = new THREE.MeshStandardMaterial({ 
                            color: 0x444444, metalness: 0.2, roughness: 0.8 
                        });
                    } else if (child.name.includes('Text')) {
                        child.material = new THREE.MeshStandardMaterial({ 
                            color: 0x2b5797, metalness: 0.8, roughness: 0.6 
                        });
                    } else if (child.name.includes('Window_Glass')) {
                        child.material = new THREE.MeshBasicMaterial({
                            color: 0x55aaff, transparent: true, opacity: 0.4, side: THREE.DoubleSide 
                        });
                    } else if (child.name.includes('Room') || child.name.includes('Door_')){
                        child.material = matteGrayMaterial; 
                    }
                    objectsToCollide.push(child);
                }
                if (child.name.includes('Door')) {
                    child.userData.isOpen = false; 
                    child.userData.baseRotationY = child.rotation.y;
                    child.userData.targetRotationY = child.rotation.y; 
                    interactiveDoors.push(child);
                }
                if (child.name.includes('Shutter')) {
                    child.userData.isSlid = false;
                    child.userData.basePosZ = child.position.z;
                    child.userData.targetPosZ = child.position.z;
                    interactiveShutters.push(child);
                }
            });
        });

        const controls = new THREE.PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const joyContainer = document.getElementById('joystick-container');
        const knob = document.getElementById('joystick-knob');
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        blocker.addEventListener('click', () => { 
            if (!isMobile) controls.lock(); 
            blocker.style.display = 'none';
            if (isMobile) joyContainer.style.display = 'block';
        });
        controls.addEventListener('lock', () => { blocker.style.display = 'none'; });
        controls.addEventListener('unlock', () => { if(!isMobile) blocker.style.display = 'flex'; });

        const raycaster = new THREE.Raycaster();
        function triggerInteract() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(roomModel ? roomModel.children : [], true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;

                // --- 核心修改：通过摄像机高度计算玩家当前所在楼层 ---
                // 摄像机默认在1层时 y=1.6，2层时 y=4.6，以此类推。
                // 除以层高(3.0)向下取整再加1，完美换算为 1, 2, 3, 4 层
                let playerFloor = Math.floor(camera.position.y / FLOOR_HEIGHT) + 1;

                // 1. 处理遮光板 (Shutter)
                let shutterObj = obj;
                while(shutterObj.parent && !shutterObj.name.includes('Shutter')) {
                    if(shutterObj.parent.type === 'Scene') break; shutterObj = shutterObj.parent;
                }
                if (shutterObj.name.includes('Shutter')) {
                    // 同样为遮光板加上楼层限制
                    let match = shutterObj.name.match(/_([1-4])/);
                    let shutterFloor = match ? parseInt(match[1]) : 1;
                    if (shutterFloor !== playerFloor) {
                        console.log(`跨层阻断：玩家在 ${playerFloor} 层，无法操作 ${shutterFloor} 层的遮光板！`);
                        return;
                    }

                    if (!shutterObj.userData.isSlid) {
                        shutterObj.userData.targetPosZ = shutterObj.userData.basePosZ - 0.8;
                        shutterObj.userData.isSlid = true;
                    } else {
                        shutterObj.userData.targetPosZ = shutterObj.userData.basePosZ;
                        shutterObj.userData.isSlid = false;
                    }
                    return; 
                }

                // 2. 处理门 (Door)
                let doorObj = obj;
                while(doorObj.parent && !doorObj.name.includes('Door')) {
                    if(doorObj.parent.type === 'Scene') break; doorObj = doorObj.parent;
                }
                
                if (doorObj.name.includes('Door')) {
                    let isOpening = !doorObj.userData.isOpen;
                    
                    let match = doorObj.name.match(/_([1-4])/);
                    let doorFloor = match ? parseInt(match[1]) : 1;

                    // 【新增：同层绝对限制】
                    if (doorFloor !== playerFloor) {
                        console.warn(`跨层阻断：玩家当前在 ${playerFloor} 楼，无法触碰 ${doorFloor} 楼的门！`);
                        return; 
                    }

                    // 【卷宗核心机制】：电梯移动中禁止开门；二层及以上电梯不在当前层时禁止开门
                    if (isOpening) {
                        if (isElevatorMoving) return; 
                        if (doorFloor >= 2 && currentElevatorFloor !== doorFloor) {
                            console.warn(`安全锁强制拦截：电梯当前在 ${currentElevatorFloor} 楼，无法打开 ${doorFloor} 楼的门！`);
                            return; 
                        }
                    }

                    let swingDir = doorObj.name.includes('Rev') ? 1 : -1;
                    doorObj.userData.targetRotationY = isOpening ? 
                        doorObj.userData.baseRotationY + swingDir * (Math.PI / 4) : doorObj.userData.baseRotationY; 
                    doorObj.userData.isOpen = isOpening;
                }
            }
        }
        window.addEventListener('mousedown', (e) => { if (!isMobile && controls.isLocked && e.button === 0) triggerInteract(); });

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        document.addEventListener('keydown', (e) => {
            if(e.code==='KeyW') moveForward=true; if(e.code==='KeyS') moveBackward=true;
            if(e.code==='KeyA') moveLeft=true; if(e.code==='KeyD') moveRight=true;

            // --- 新增：键盘快捷呼叫电梯 (仅在电梯条件满足时生效) ---
            if (isPlayerOnElevator && isAllCurrentDoorsClosed && !isElevatorMoving) {
                if (e.code === 'Digit1' || e.code === 'Numpad1') window.callElevator(1);
                if (e.code === 'Digit2' || e.code === 'Numpad2') window.callElevator(2);
                if (e.code === 'Digit3' || e.code === 'Numpad3') window.callElevator(3);
                if (e.code === 'Digit4' || e.code === 'Numpad4') window.callElevator(4);
            }
        });
        document.addEventListener('keyup', (e) => {
            if(e.code==='KeyW') moveForward=false; if(e.code==='KeyS') moveBackward=false;
            if(e.code==='KeyA') moveLeft=false; if(e.code==='KeyD') moveRight=false;
        });

        // 移动端触摸逻辑 (保持不变)
        let touchMoveId = null, touchLookId = null;
        let lastTouchX, lastTouchY;
        let touchStartTime, touchStartX, touchStartY;

        window.addEventListener('touchstart', (e) => {
            if (!isMobile) return;
            // 判断点击是否在 UI 面板上，如果是则放行原生事件
            if (e.target.classList.contains('ele-btn')) return;

            for(let t of e.changedTouches) {
                if(t.pageX < window.innerWidth / 2) {
                    touchMoveId = t.identifier;
                } else {
                    touchLookId = t.identifier; 
                    lastTouchX = t.pageX; lastTouchY = t.pageY;
                    touchStartTime = Date.now(); touchStartX = t.pageX; touchStartY = t.pageY;
                }
            }
        });

        window.addEventListener('touchmove', (e) => {
            if (!isMobile) return;
            for(let t of e.changedTouches) {
                if(t.identifier === touchMoveId) {
                    let dx = t.pageX - 110, dy = t.pageY - (window.innerHeight - 110);
                    let dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
                    let angle = Math.atan2(dy, dx);
                    knob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                    
                    let joyY = Math.sin(angle) * (dist/50);
                    let joyX = Math.cos(angle) * (dist/50);
                    moveForward = joyY < -0.2; moveBackward = joyY > 0.2;
                    moveLeft = joyX < -0.2; moveRight = joyX > 0.2;
                }
                if(t.identifier === touchLookId) {
                    camera.rotation.y -= (t.pageX - lastTouchX) * 0.005;
                    camera.rotation.x -= (t.pageY - lastTouchY) * 0.005;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    lastTouchX = t.pageX; lastTouchY = t.pageY;
                }
            }
        });

        window.addEventListener('touchend', (e) => {
            if (!isMobile) return;
            for(let t of e.changedTouches) {
                if(t.identifier === touchMoveId) {
                    moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
                    knob.style.transform = 'translate(0,0)'; touchMoveId = null;
                }
                if(t.identifier === touchLookId) {
                    let dt = Date.now() - touchStartTime;
                    let moveDist = Math.abs(t.pageX - touchStartX) + Math.abs(t.pageY - touchStartY);
                    if (dt < 250 && moveDist < 10) triggerInteract();
                    touchLookId = null;
                }
            }
        });

        let prevTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            
            if (controls.isLocked || isMobile) {
                const delta = (time - prevTime) / 1000;
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const playerDir = new THREE.Vector3();
                camera.getWorldDirection(playerDir);
                playerDir.y = 0; playerDir.normalize();

                const checkCollision = (dir) => {
                    raycaster.set(camera.position, dir);
                    const hits = raycaster.intersectObjects(objectsToCollide, false);
                    return hits.length > 0 && hits[0].distance < 0.8;
                };

                if (moveForward && !checkCollision(playerDir)) velocity.z -= direction.z * 40.0 * delta;
                if (moveBackward && !checkCollision(playerDir.clone().negate())) velocity.z -= direction.z * 40.0 * delta;
                if (moveLeft && !checkCollision(playerDir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI/2))) velocity.x -= direction.x * 40.0 * delta;
                if (moveRight && !checkCollision(playerDir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), -Math.PI/2))) velocity.x -= direction.x * 40.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
            }

            // --- 新增：电梯引擎与条件判定系统 ---
            // 1. 判断玩家是否位于中央天井（电梯平台范围内，假设电梯半径为 3.0）
            isPlayerOnElevator = Math.abs(camera.position.x) <= 3.0 && Math.abs(camera.position.z) <= 3.0;

            // 2. 检查当前楼层的【外室门】是否已全部关好
            isAllCurrentDoorsClosed = true;
            interactiveDoors.forEach(door => {
                // 核心修改：只关注名字里带有 "Outer" 的外室门
                if (door.name.includes('Outer')) {
                    // 提取楼层数，支持 Door_303_Outer 或 Door_Active_3_Outer 这样的命名
                    let match = door.name.match(/_([1-4])/);
                    let doorFloor = match ? parseInt(match[1]) : 1;
                    
                    // 如果是当前楼层的外室门，且它现在是开着的，就锁定电梯
                    if (doorFloor === currentElevatorFloor && door.userData.isOpen) {
                        isAllCurrentDoorsClosed = false;
                    }
                }
            });
            // 3. UI 控制面板显隐逻辑
            const panel = document.getElementById('elevator-panel');
            if (isPlayerOnElevator && isAllCurrentDoorsClosed && !isElevatorMoving) {
                panel.style.display = 'flex';
            } else {
                panel.style.display = 'none';
            }

            // 4. 电梯平台与玩家视角同步升降物理引擎
            if (isElevatorMoving && elevatorObj) {
                let targetY = (targetElevatorFloor - 1) * FLOOR_HEIGHT;
                let currentY = elevatorObj.position.y;
                let dy = targetY - currentY;
                
                // 如果距离目标还有一定间距，执行平滑移动
                if (Math.abs(dy) > 0.05) {
                    let delta = dy * 0.03; // 缓动比例
                    // 保证一个最小移动速度
                    if (Math.abs(delta) < 0.02) delta = Math.sign(dy) * 0.02; 
                    
                    elevatorObj.position.y += delta;
                    // 同步抬升/下降玩家摄像机的高度！
                    camera.position.y += delta;
                } else {
                    // 到达目标，进行坐标对齐缝合
                    let finalDelta = targetY - elevatorObj.position.y;
                    elevatorObj.position.y = targetY;
                    camera.position.y += finalDelta; 
                    currentElevatorFloor = targetElevatorFloor;
                    isElevatorMoving = false;
                }
            }
            // ----------------------------------

            interactiveDoors.forEach(door => {
                door.rotation.y = THREE.MathUtils.lerp(door.rotation.y, door.userData.targetRotationY, 0.1);
            });

            interactiveShutters.forEach(shutter => {
                shutter.position.z = THREE.MathUtils.lerp(shutter.position.z, shutter.userData.targetPosZ, 0.1);
            });

            prevTime = time;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>